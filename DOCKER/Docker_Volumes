
# Docker volume
=================

# How to Manage data in Docker?

  - By default all files created inside a container are stored on a writable container layer. This means that:

	- The data doesn’t persist when that container no longer exists, and it can be difficult to get the data out of the container,if another process needs it.
	- A container’s writable layer is tightly coupled to the host machine where the container is running. You can’t easily move the data somewhere else.
	- Writing into a container’s writable layer requires a storage driver to manage the filesystem.The storage driver provides a union filesystem, using the Linux kernel.This extra abstraction reduces performance as compared to using data volumes, which write directly to the host filesystem.


# Docker has three ways of persisting data.

  - volumes, bind mounts, tmpfs mount. If you’re running Docker on Linux you can also use a tmpfs mount.


# Difference between volumes, bind mounts, and tmpfs?

	- Volumes are stored in a part of the host filesystem which is managed by Docker (/var/lib/docker/volumes/ on Linux). Non-Docker processes should not modify this part of the filesystem. Volumes 		 are the best way to persist data in Docker.

	- Bind mounts may be stored anywhere on the host system. They may even be important system files or directories. Non-Docker processes on the Docker host or a Docker container can modify them at 	any time.

	- tmpfs mounts are stored in the host system’s memory only, and are never written to the host system’s filesystem.
	   

# What is volumes?

	- Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. volumes are completely managed by Docker.

# Advantages of Volumes?

	- Volumes are easier to back up or migrate than bind mounts.
	- You can manage volumes using Docker CLI commands or the Docker API.
	- Volumes work on both Linux and Windows containers.
	- Volumes can be more safely shared among multiple containers.
	- Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the 	contents of volumes, or to add other functionality.
	- New volumes can have their content pre-populated by a container.
  	-In addition, volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container.


# Create a volume:

	$ docker volume create vol1


# List volumes:

	$ docker volume ls  (Note:- This command shows the volume name and info.)

	local  <Volume-Name>


# Inspect a volume:

	$ docker volume inspect <Volume-Name>  (Note:- This command shows the info about volume, on which location container data will be stored.)

	Example:[
		    {
			"CreatedAt": "2019-02-03T12:13:48+05:30",
			"Driver": "local",
			"Labels": null,
			"Mountpoint": "/var/lib/docker/volumes/<Volume-Name>/_data",
			"Name": "mysqlvol",
			"Options": null,
			"Scope": "local"
		    }
		]


# Remove a volume:

	$ docker volume rm <Volume-Name>


# Choose the -v or --mount flag

	- Originally, the -v or --volume flag was used for standalone containers and the --mount flag was used for swarm services. 
	- However, starting with Docker 17.06, you can also use --mount with standalone containers. In general, --mount is more explicit and verbose. 
	- The biggest difference is that the -v syntax combines all the options together in one field, while the --mount syntax separates them. 
	
	- Here is a comparison of the syntax for each flag.

		- New users should try --mount syntax which is simpler than --volume syntax.
		- If you need to specify volume driver options, you must use --mount.


# $ docker pull <mysql-image>

# $ docker inspect <mysql-image> 
	Note :- Here find out the volume path for mysql. ie. default path is ("volumes": "/var/lib/mysql")

# $ docker container run -d --name <container-name> -e MYSQL_ALLOW_EMPTY_PASSWORD=true <mysql-image>

	Note:- If container will be delated, but in volume all data will be stored.

# $ docker container exec -it <container-name> /bin/bash

# $ docker container run -d --name <container-name> -e MYSQL_ALLOW_EMPTY_PASSWORD=true -v vol1:/var/lib/mysql mysql

	Note:- Using this command we can give name to volume, so we can easily find out the which volume is used for specific container. 
	       we can use same volume for multiple containers.
	       For development purpose this run command is useful for docker volume. But in production we use create command for creating volume.

# $ go to your root and find the mount path of the volume your all container data will be stored in the location.
	Ex. # cd /var/lib/docker/volumes/mysqlvol/_data# 


# Bind Mounting
================
	- Bind Mount is act like bridging between local files access and apps running in containers.
	- In bind mounts we edit files on our host using native tools.
	- containers detects changes with hosts files and updates web server.
	- Maps a host file or directoy to container file or directory
	- Basically just two locations pointing two the same files.
	- See, My working file is in my current directory ie. outside the running container and I want to map or execute this file inside container use bind mount. use below command :
	  
		$ docker container run -d --name <container-name> -p 8080:80 -v $(pwd):/usr/share/nginx/html <nginx-image>
                     Note:- you will see the nginx custom image output
		$ docker container run -d --name <container-name> -p 8080:80 <nginx-image>
		     Note:- you will see the real nginx default output page., Now open one new terminal and enter into that container using exec command
		
		$ docker container exec -it <container-name> bash
		     Note:- If we are changing the container port then use the above command for enter into that container. 
	- Now create one file outside the container and run the nginx browser.
	- Now create one file outside the container and check the file is coming into the container ie. nginx directory or not.
	- Then write somthing into the outside directory using this command ($ echo "is it me" > filename) and chek to the container nginx directory.

# Real Time Scenario 
====================
 1)Upgrade database in docker, in same volume
 	=> First create a container using older version(postger)
	$ docker container run -d --name <container-name> -v <volume-name>:/var/lib/postgresql/data postgres:9.6.1
	
	$ docker container logs -f <container-name>
		Note:- keep watching on container creation
	
	$ docker container -d --name <container-name> -v <volume-name>:/var/lib/postgresql/data postgres:9.6.2

==================================================================



